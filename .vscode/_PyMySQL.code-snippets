{
	// Place your CodingDojo workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Create mysqlconnection": {
		"prefix": "~PyMy",
		"body": [
		"# a cursor is the object we use to interact with the database",
		"import pymysql.cursors",
		"",
		"",
		"# this class will give us an instance of a connection to our database",
		"class MySQLConnection:",
		"    def __init__(self, db):",
		"        connection = pymysql.connect(host = 'localhost',",
		"                                    user = 'root', # change the user and password as needed",
		"                                    password = 'root', ",
		"                                    db = db,",
		"                                    charset = 'utf8mb4',",
		"                                    cursorclass = pymysql.cursors.DictCursor,",
		"                                    autocommit = True)",
		"        # establish the connection to the database",
		"        self.connection = connection",
		"",
		"    # the method to query the database",
		"    def query_db(self, query, data=None):",
		"        with self.connection.cursor() as cursor:",
		"            try:",
		"                query = cursor.mogrify(query, data)",
		"                print(\"Running Query:\", query)",
		"                executable = cursor.execute(query, data)",
		"                if query.lower().find(\"insert\") >= 0:",
		"                    # INSERT queries will return the ID NUMBER of the row inserted",
		"                    self.connection.commit()",
		"                    return cursor.lastrowid",
		"                elif query.lower().find(\"select\") >= 0:",
		"                    # SELECT queries will return the data from the database as a LIST OF DICTIONARIES",
		"                    result = cursor.fetchall()",
		"                    return result",
		"                else:",
		"                    # UPDATE and DELETE queries will return nothing",
		"                    self.connection.commit()",
		"            except Exception as e:",
		"                # if the query fails the method will return FALSE",
		"                print(\"Something went wrong\", e)",
		"                return False",
		"            finally:",
		"                # close the connection",
		"                self.connection.close() ",
		"",
		"# connectToMySQL receives the database we're using and uses it to create an instance of MySQLConnection",
		"def connectToMySQL(db):",
		"    return MySQLConnection(db)"
		],
		"description": "Create mysqlconnection"
	},

	"create server.py": {
		"prefix": "~server",
		"body": [
		"from flask import Flask, render_template, redirect, request",
		"from flask_app import app",
		"from flask_app.controllers import ninjas, dojos",
		"",
		"if __name__==\"__main__\":",
		"    app.run(debug=True)"
		],
		"description": "create server.py"
	},
	"create model_.py": {
		"prefix": "~model",
		"body": [
		"#Get the connection ",
		"from flask_app.config.mysqlconnection import connectToMySQL ",
		"from flask_app import DATABASE_SCHEMA",
		"# DATABASE = 'CHANGE DATABASE'",
		"#REMEMBER TO REPLACE THE TABLE",
		"",
		"class Author:",
		"    def __init__(self,data): #DON'T FORGET TO INITIALIZE EVERY FIELD YOU USE",
		"        self.id = data['id']",
		"        self.name= data['name']",
		"        self.bun = data['bun']",
		"        self.meat = data['meat']",
		"        self.calories = data['calories']",
		"        self.created_at = data['created_at']",
		"        self.updated_at = data['updated_at']",
		"    ",
		"    #get_all",
		"    #get_one",
		"    #create / save",
		"    #update_one",
		"    #delete_one",
		"",
		"    #if you use data then remember to match up the %(same_key)s ",
		"",
		"    # C",
		"    @classmethod",
		"    def create(cls,data:dict) -> int: #The expected return is int",
		"        query = \"INSERT INTO {TABLE} (FIELDS) VALUES (%(FIELDS)s)\"",
		"        user_id = connectToMySQL(DATABASE_SCHEMA).query_db(query,data)",
		"        return user_id",
		"",
		"    # R",
		"    @classmethod",
		"    def get_all(cls) -> list: #This is a get all and will return a list of dictionaries",
		"        query = \"SELECT * FROM authors;\"",
		"        results_from_db =  connectToMySQL(DATABASE_SCHEMA).query_db(query) #Gets a list of dictionaries....",
		"        to_object =[] ",
		"        if results_from_db:",
		"            for values in results_from_db :  #turn those dictionaries into objects",
		"                to_object.append(cls(values))",
		"            return to_object",
		"        else : return []",
		"        ",
		"",
		"    @classmethod",
		"    def get_one(cls, data) -> list: #this is the same",
		"        query = \"SELECT * FROM {TABLE} WHERE id= %(id)s \"",
		"        results_from_db = connectToMySQL(DATABASE_SCHEMA).query_db(query,data)",
		"        to_object = []",
		"        if results_from_db:",
		"            for values in results_from_db :  #turn those dictionaries into objects",
		"                to_object.append(cls(values))",
		"            return to_object",
		"        else : return []",
		"            ",
		"",
		"    # U",
		"    @classmethod",
		"    def save(cls,data): #RETURNS NOTHING",
		"        query = \"UPDATE {CLASS} SET value= %(value)s WHERE id=%(id)s\"",
		"        return connectToMySQL(DATABASE_SCHEMA).query_db(query,data)",
		"",
		"    # D",
		"    @classmethod ",
		"    def delete(cls,data): #RETURNS NOTHING",
		"        query = \"DELETE FROM {TABLE} WHERE id=%(id)s;\"",
		"        # This would target a field and flag is as disabled so we get to keep the data.",
		"        # query = \"UPDATE {TABLE} SET account_disabled=true WHERE id = %(id)s\"",
		"        return connectToMySQL(DATABASE_SCHEMA).query_db(query,data)",
		""
		],
		"description": "create model_.py"
	},
	"create controller_.py": {
		"prefix": "~controller",
		"body": [
		"#import the app",
		"from flask_app import app",
		"#Then import the important flask responses",
		"from flask import render_template,redirect,request,session,flash",
		"#then import the SAME relative file",
		"from flask_app.models.[table_name] import [ClassName] #Importing the object we're manipulating",
		"",
		"MODEL = [CLASSNAME]",
		"",
		"@app.route('/')",
		"def index():",
		"    return render_template(\"index.html\")",
		"",
		"#Some of restful Routing",
		"#Path should be '/TABLE_NAME/ID/ACTION'",
		"#/User/new",
		"#/user/create",
		"#/user/<id>/edit",
		"#/user/<id>/update",
		"#/user/<id>/delete",
		"",
		"@app.route(\"/TABLE/new\")        #render route",
		"def get_form():",
		"    return render_template(\"TABLE_form.html\")",
		"",
		"#So this is what happens when the URL reaches that ROUTE",
		"@app.route('/TABLE/create',methods=['POST']) #action route",
		"def create():",
		"    user_id = MODEL.create(request.form)",
		"    return redirect(f'/TABLE/{user_id}')",
		"",
		"@app.route(\"/TABLE/<int:id>\")",
		"def view(id):",
		"    context = {",
		"        \"items\" : MODEL.get_one({\"id\": id})",
		"    }",
		"    return render_template(\"TABLE_edit.html\", **context)",
		"",
		"",
		"@app.route(\"/TABLE/<int:id>/edit\")",
		"def edit(id):",
		"    context = {",
		"        \"items\" : MODEL.get_one({\"id\": id})",
		"    }",
		"    return render_template(\"TABLE.html\", **context)",
		"",
		"@app.route(\"/TABLE/<int:id>/update\", methods=['POST'])",
		"def update(id):",
		"    nothing = MODEL.update(request.form)",
		"    return redirect(f\"/TABLE/{id}\")",
		"",
		"",
		"@app.route(\"/TABLE/<int:id>/delete\", methods=['POST'])",
		"def delete(id):",
		"    nothing = MODEL.delete({\"id\":id})",
		"    return redirect(\"/\")  #"
		],
		"description": "create controller_.py"
	
	},"create __init__.py": {
		"prefix": "~init",
		"body": [
		"from flask import Flask",
		"app = Flask(__name__)",
		"app.secret_key ='Shhhh'",
		"",
		"",
		"if __name__==\"main\":",
		"    app.run(debug=True)",
		"",
		"DATABASE_SCHEMA=''"
		],
		"description": "create __init__.py"
	},
	"create index.html": {
		"prefix": "~index.html",
		"body": [
		"<!DOCTYPE html>",
		"<html lang=\"en\">",
		"<head>",
		"    <meta charset=\"UTF-8\">",
		"    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">",
		"    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">",
		"    <title>Friendships</title>",
		"    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\" crossorigin=\"anonymous\">",
		"    <link rel=\"stylesheet\" href=\"{{url_for('static',filename='css/style.css')}}\">",
		"</head>",
		"<body>",
		"    <div class=\"container d-flex justify-content-around\">",
		"    </div>",
		"</body>",
		"</html>"
		],
		"description": "create index.html"
	},

	"For Loop": {
		"prefix": ["for", "for-const"],
		"body": ["for (const ${2:element} of ${1:array}) {", "\t$0", "}", " ${1:array}", " ${2:array}"],
		"description": "A for loop."
	}

}

